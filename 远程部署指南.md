# 海尔销售分析系统远程部署完整指南

## 🎯 部署目标

### 系统架构概述
- **影刀RPA执行环境**: Windows机器，数据源为ERP数据库
- **EdgeOne服务**: 远程服务器部署，域名 `https://edge.haierht.cn`
- **企业微信服务器**: `212.64.57.87:5001`

### 主要部署任务
1. 将企业微信服务器 `wecomchan_server_updated.py` 部署到 `212.64.57.87:5001`
2. 配置EdgeOne Pages服务，实现HTML报告的CDN分发
3. 确保影刀RPA脚本能正确连接数据库和远程服务

## 📋 部署前准备

### 1. 连接到远程服务器
```

## 🚨 CDN配置问题修复记录

### 问题描述
- **时间**: 2025-07-30 09:22
- **现象**: 脚本成功生成HTML报告并通过API部署到远程服务器，API返回200状态码，但CDN域名 `https://edge.haierht.cn/reports/` 返回404错误
- **影响**: 用户无法通过公网链接访问生成的报告

### 问题分析
1. **本地脚本**: 正常运行，成功生成带时间戳的HTML文件
2. **远程API**: 正常工作，POST请求返回200状态码
3. **文件存储**: 文件成功保存到远程服务器 `/root/reports/` 目录
4. **Flask服务器**: 可以正常提供文件服务 (`http://212.64.57.87:5002/reports/文件名` 返回200)
5. **CDN问题**: `https://edge.haierht.cn/reports/文件名` 返回404错误

### 技术细节
```bash
# 验证文件存在
ssh root@212.64.57.87 'ls -la /root/reports/overall_daily_2025-07-29_092140.html'
# 结果: 文件存在，大小95119字节

# 验证Flask服务器
curl -I http://212.64.57.87:5002/reports/overall_daily_2025-07-29_092140.html
# 结果: HTTP/1.1 200 OK

# 验证CDN
curl -I https://edge.haierht.cn/reports/overall_daily_2025-07-29_092140.html
# 结果: HTTP/2 404 (x-cos-error-code: NoSuchKey)
```

### 根本原因
CDN (edge.haierht.cn) 没有正确代理到Flask服务器 (212.64.57.87:5002)，或者CDN配置存在问题。

### 临时解决方案
用户可以直接使用Flask服务器地址访问报告：
```
http://212.64.57.87:5002/reports/文件名
```

### 待解决
- [ ] 检查CDN配置，确保正确代理到Flask服务器
- [ ] 联系CDN管理员解决域名解析问题
- [ ] 考虑更新脚本，在CDN修复前使用直接地址

---bash
# 使用SSH连接到远程服务器（替换为你的实际用户名）
ssh root@212.64.57.87
# 或者
ssh username@212.64.57.87
```

### 2. 检查当前服务状态
```bash
# 查看当前运行的Python进程
ps aux | grep python
ps aux | grep wecomchan

# 查看端口占用情况
netstat -tlnp | grep 5001
# 或者使用 ss 命令
ss -tlnp | grep 5001

# 查看当前工作目录
pwd
ls -la
```

## 🛑 停止旧服务

### 方法1: 使用进程ID停止
```bash
# 找到wecomchan相关进程的PID
ps aux | grep wecomchan_server.py

# 停止进程（替换XXXX为实际的PID）
kill XXXX
# 如果无法正常停止，使用强制停止
kill -9 XXXX
```

### 方法2: 使用pkill停止
```bash
# 停止所有wecomchan相关进程
pkill -f wecomchan_server
pkill -f python.*wecomchan

# 确认进程已停止
ps aux | grep wecomchan
```

### 方法3: 如果使用了systemd服务
```bash
# 停止服务（如果配置了systemd）
sudo systemctl stop wecomchan
sudo systemctl disable wecomchan
```

## 📂 备份和更新代码

### 1. 备份原有文件
```bash
# 创建备份目录
mkdir -p ~/wecomchan_backup/$(date +%Y%m%d_%H%M%S)

# 备份原有的服务器文件
cp wecomchan_server.py ~/wecomchan_backup/$(date +%Y%m%d_%H%M%S)/
cp -r . ~/wecomchan_backup/$(date +%Y%m%d_%H%M%S)/ 2>/dev/null || true

echo "备份完成，备份位置: ~/wecomchan_backup/$(date +%Y%m%d_%H%M%S)/"
```

### 2. 上传新的服务器文件

#### 方法A: 使用scp从本地上传（在本地执行）
```bash
# 在本地机器上执行，上传新的服务器文件
scp wecomchan_server_updated.py root@212.64.57.87:~/wecomchan_server_updated.py
```

#### 方法B: 在服务器上直接创建文件
```bash
# 在服务器上创建新的服务器文件
cat > wecomchan_server_updated.py << 'EOF'
# 这里需要粘贴完整的 wecomchan_server_updated.py 内容
# 由于文件较大，建议使用方法A或方法C
EOF
```

#### 方法C: 使用wget下载（如果文件在网上）
```bash
# 如果你把文件放在了GitHub或其他地方
wget -O wecomchan_server_updated.py "你的文件URL"
```

## 🔧 安装依赖

### 1. 检查Python环境
```bash
# 检查Python版本
python3 --version
which python3

# 检查pip
pip3 --version
which pip3
```

### 2. 安装必要的依赖
```bash
# 安装Flask和requests
pip3 install flask requests

# 如果遇到权限问题，使用用户安装
pip3 install --user flask requests

# 如果使用的是Python 2，需要使用pip
pip install flask requests
```

### 3. 验证依赖安装
```bash
# 验证Flask安装
python3 -c "import flask; print('Flask version:', flask.__version__)"

# 验证requests安装
python3 -c "import requests; print('Requests version:', requests.__version__)"
```

## 🚀 启动新服务

### 1. 测试新服务器文件
```bash
# 先测试新文件是否能正常启动（前台运行，便于调试）
python3 wecomchan_server_updated.py
```

如果看到类似以下输出，说明启动成功：
```
 * Running on all addresses (0.0.0.0)
 * Running on http://127.0.0.1:5001
 * Running on http://[你的内网IP]:5001
```

按 `Ctrl+C` 停止测试。

### 2. 后台启动服务

#### 方法A: 使用nohup
```bash
# 后台启动服务，日志输出到文件
nohup python3 wecomchan_server_updated.py > wecomchan.log 2>&1 &

# 查看进程
ps aux | grep wecomchan_server_updated

# 查看日志
tail -f wecomchan.log
```

#### 方法B: 使用screen（推荐）
```bash
# 安装screen（如果没有）
yum install screen -y  # CentOS/RHEL
# 或
apt-get install screen -y  # Ubuntu/Debian

# 创建screen会话
screen -S wecomchan

# 在screen中启动服务
python3 wecomchan_server_updated.py

# 按 Ctrl+A 然后按 D 退出screen（服务继续运行）

# 重新连接到screen会话
screen -r wecomchan

# 查看所有screen会话
screen -ls
```

#### 方法C: 创建systemd服务（推荐生产环境）
```bash
# 创建服务文件
sudo cat > /etc/systemd/system/wecomchan.service << EOF
[Unit]
Description=WeComChan Server
After=network.target

[Service]
Type=simple
User=root
WorkingDirectory=$(pwd)
ExecStart=/usr/bin/python3 $(pwd)/wecomchan_server_updated.py
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
EOF

# 重新加载systemd配置
sudo systemctl daemon-reload

# 启动服务
sudo systemctl start wecomchan

# 设置开机自启
sudo systemctl enable wecomchan

# 查看服务状态
sudo systemctl status wecomchan

# 查看服务日志
sudo journalctl -u wecomchan -f
```

## ✅ 验证部署

### 1. 检查服务状态
```bash
# 检查端口是否监听
netstat -tlnp | grep 5001
ss -tlnp | grep 5001

# 检查进程
ps aux | grep wecomchan
```

### 2. 本地测试
```bash
# 在服务器上测试健康检查
curl http://localhost:5001/health

# 测试部门列表
curl "http://localhost:5001/departments?token=wecomchan_token"
```

### 3. 远程测试（在本地执行）
```bash
# 在本地机器上测试远程服务器
curl http://212.64.57.87:5001/health

# 运行之前创建的测试脚本
python3 server_test.py
```

## 🔥 防火墙配置

### 1. 检查防火墙状态
```bash
# CentOS/RHEL 7+
systemctl status firewalld
firewall-cmd --list-all

# Ubuntu/Debian
ufw status

# 通用方法
iptables -L -n
```

### 2. 开放5001端口（如果需要）
```bash
# CentOS/RHEL (firewalld)
firewall-cmd --permanent --add-port=5001/tcp
firewall-cmd --reload

# Ubuntu/Debian (ufw)
ufw allow 5001/tcp

# 直接使用iptables
iptables -A INPUT -p tcp --dport 5001 -j ACCEPT
# 保存iptables规则
service iptables save  # CentOS/RHEL
iptables-save > /etc/iptables/rules.v4  # Ubuntu/Debian
```

## 🔍 故障排查

### 1. 服务无法启动
```bash
# 查看错误信息
python3 wecomchan_server_updated.py

# 检查依赖
pip3 list | grep -E "(flask|requests)"

# 检查端口占用
lsof -i :5001
```

### 2. 服务启动但无法访问
```bash
# 检查监听地址
netstat -tlnp | grep 5001

# 检查防火墙
systemctl status firewalld
firewall-cmd --list-all

# 检查服务器日志
tail -f wecomchan.log
# 或
sudo journalctl -u wecomchan -f
```

### 3. 企业微信API错误
```bash
# 检查企业微信配置
grep -E "(CORP_ID|CORP_SECRET|AGENT_ID)" wecomchan_server_updated.py

# 测试企业微信连接
curl "http://localhost:5001/departments?token=wecomchan_token"
```

## 📝 完整部署脚本

将以下脚本保存为 `deploy.sh` 并执行：

```bash
#!/bin/bash

echo "🚀 开始部署企业微信服务器..."

# 1. 停止旧服务
echo "1️⃣ 停止旧服务..."
pkill -f wecomchan_server.py
pkill -f wecomchan_server_updated.py
sleep 2

# 2. 备份
echo "2️⃣ 备份原有文件..."
BACKUP_DIR=~/wecomchan_backup/$(date +%Y%m%d_%H%M%S)
mkdir -p $BACKUP_DIR
cp *.py $BACKUP_DIR/ 2>/dev/null || true
echo "备份完成: $BACKUP_DIR"

# 3. 检查依赖
echo "3️⃣ 检查依赖..."
python3 -c "import flask, requests" 2>/dev/null || {
    echo "安装依赖..."
    pip3 install flask requests
}

# 4. 启动新服务
echo "4️⃣ 启动新服务..."
nohup python3 wecomchan_server_updated.py > wecomchan.log 2>&1 &
sleep 3

# 5. 验证
echo "5️⃣ 验证部署..."
if curl -s http://localhost:5001/health > /dev/null; then
    echo "✅ 部署成功！服务正常运行"
    echo "📊 进程信息:"
    ps aux | grep wecomchan_server_updated.py | grep -v grep
else
    echo "❌ 部署失败，请检查日志:"
    tail -10 wecomchan.log
fi

echo "🎉 部署完成！"
```

执行部署：
```bash
# 给脚本执行权限
chmod +x deploy.sh

# 执行部署
./deploy.sh
```

## 📞 部署后测试

部署完成后，在本地运行测试脚本验证：
```bash
# 在本地执行
python3 server_test.py
```

应该看到远程服务器的功能测试结果从之前的20%提升到60%以上。

---

## 💡 小贴士

1. **建议使用screen或systemd**：确保服务稳定运行
2. **定期备份**：在更新前始终备份原有文件
3. **监控日志**：定期查看服务日志确保正常运行
4. **安全考虑**：考虑配置SSL证书和访问控制

如果遇到问题，请提供具体的错误信息，我会帮你解决！

---

## 📋 客户端脚本URL处理问题修复记录 (2025-01-27)

### 🔍 问题发现
通过运行 `整体日报数据.py` 脚本发现，虽然远程Web部署API正常运行并返回200状态码，但客户端仍报告404错误。

### 🕵️ 问题分析
1. **错误的URL路径替换**：在 `upload_html_and_get_url` 函数中存在错误逻辑
   ```python
   # 错误的代码
   public_url = public_url.replace('/reports/', '/')
   ```
   这会将API返回的正确URL `http://edge.haierht.cn/reports/xxx.html` 错误地修改为 `http://edge.haierht.cn/xxx.html`

2. **复杂的URL测试逻辑**：在第2210-2230行附近存在URL测试逻辑，会尝试访问错误的URL路径
   ```python
   # 问题代码
   test_url1 = url1
   test_url2 = url1.replace('/reports/', '/') if '/reports/' in url1 else None
   # 会尝试访问错误的路径，导致404
   ```

### 🔧 解决方案
1. **修复URL替换逻辑**：删除 `upload_html_and_get_url` 函数中的路径替换代码
   ```python
   # 修复后：直接使用API返回的URL
   return response_data.get('url')
   ```

2. **简化URL处理逻辑**：删除复杂的URL测试逻辑，直接使用API返回的URL
   ```python
   # 修复后：直接使用API返回的URL，不进行路径替换测试
   public_url = url1
   ```

### ✅ 修复结果
- ✅ 脚本成功运行，无404错误
- ✅ API部署成功，返回正确的公网链接
- ✅ 微信消息发送成功
- ✅ Web报告正常发布

### 📝 技术要点
1. **根本原因**：客户端错误的URL路径处理逻辑
2. **关键修复**：保持API返回URL的完整性，避免不必要的路径替换
3. **验证方法**：直接运行脚本，检查是否出现404错误和最终的发布结果

### 💡 经验总结
1. **API集成**：客户端应严格按照API规范处理返回数据，避免自行修改URL路径
2. **错误排查**：当出现404错误时，应检查完整的请求链路，包括客户端的URL处理逻辑
3. **代码审查**：复杂的URL处理逻辑往往是bug的源头，应尽量简化

---

## 📋 5002端口Web部署服务修复记录 (2025-01-30)

### 🔍 问题发现
通过运行 `server_test.py` 发现远程服务器 `212.64.57.87:5002` 返回404错误，而非连接拒绝，表明服务器运行但API端点不可用。

### 🕵️ 问题分析
1. **API参数不匹配**：客户端代码发送的JSON参数格式与服务器端期望的参数不匹配
   - 客户端发送：`filename`、`content`、`html_content`
   - 服务器期望：`content`、`report_id`

2. **影响范围**：多个报告生成脚本无法正常部署HTML文件
   - `整体日报数据.py`
   - `整体周报数据.py` 
   - `多事业部日报数据.py`
   - `整体月报数据.py`
   - `多事业部月报数据.py`

### 🔧 解决方案
修改 `deploy_web_report_server.py` 文件，增强API兼容性：

```python
# 兼容多种JSON参数格式
content = None
filename = None

# 支持 content 或 html_content 作为内容
if 'content' in data:
    content = data['content']
elif 'html_content' in data:
    content = data['html_content']

# 支持 filename 或 report_id 作为文件名
if 'filename' in data:
    filename = data['filename']
elif 'report_id' in data:
    filename = data['report_id']

# 确保文件名以.html结尾
if filename and not filename.endswith('.html'):
    filename += '.html'
```

### 🚀 部署步骤

#### 1. 本地测试验证
```bash
# 启动本地Flask服务器
python3 deploy_web_report_server.py

# 测试兼容性 - filename + content
curl -X POST http://localhost:5002/deploy_html \
  -H "Content-Type: application/json" \
  -d '{"filename": "test_report.html", "content": "<html><body><h1>Test</h1></body></html>"}'

# 测试兼容性 - filename + html_content  
curl -X POST http://localhost:5002/deploy_html \
  -H "Content-Type: application/json" \
  -d '{"filename": "test_report2.html", "html_content": "<html><body><h1>Test2</h1></body></html>"}'
```

#### 2. 远程部署
```bash
# 上传修复后的文件到远程服务器
scp deploy_web_report_server.py root@212.64.57.87:/root/

# 连接远程服务器并重启服务
ssh root@212.64.57.87

# 停止旧服务
netstat -tlnp | grep 5002  # 查找进程ID
kill [PID]  # 停止旧进程

# 确保reports目录存在
mkdir -p /root/reports

# 启动新服务
cd /root
nohup python3 deploy_web_report_server.py > web_server.log 2>&1 &

# 验证服务启动
netstat -tlnp | grep 5002
```

#### 3. 功能验证
```bash
# 测试远程API
curl -X POST http://212.64.57.87:5002/deploy_html \
  -H "Content-Type: application/json" \
  -d '{"filename": "test_remote.html", "content": "<html><body><h1>Remote Test</h1></body></html>"}'

# 运行完整测试
python server_test.py
```

### ✅ 修复结果
- ✅ Web服务器可用 (212.64.57.87:5002)
- ✅ 消息服务器可用 (212.64.57.87:5001)
- ✅ Web部署功能可用
- ✅ 所有客户端代码现在都能正常调用远程Web部署API

### 📝 技术要点
1. **向后兼容**：保持对原有multipart/form-data方式的支持
2. **参数灵活性**：支持多种JSON参数命名方式
3. **文件名处理**：自动确保HTML文件扩展名
4. **错误处理**：完善的异常处理和日志记录

### 🔍 故障排查经验
1. **404错误 vs 连接拒绝**：404表明服务运行但端点不存在，连接拒绝表明服务未运行
2. **参数格式检查**：使用 `search_codebase` 工具查找客户端代码的实际参数格式
3. **本地测试先行**：在本地验证修复后再部署到远程服务器
4. **进程管理**：使用 `netstat` 和 `kill` 命令管理服务进程

---

## 📋 测试环境文件覆盖问题修复记录 (2025-01-30)

### 🔍 问题发现
在测试环境中，同一天多次运行报告生成脚本时，新报告会覆盖旧报告，可能导致旧报告被错误发送。

### 🕵️ 问题分析
1. **文件名冲突**：在 `save_report_to_local` 函数中，文件名格式为固定的 `reports/{report_type}_{report_date}.html`
   ```python
   filename = f"reports/{report_type}_{report_date}.html"
   # 结果: reports/overall_daily_2025-07-29.html
   ```

2. **覆盖风险**：同一天多次运行会生成相同的文件名，导致文件覆盖

3. **影响范围**：所有报告生成脚本都存在此问题
   - `整体日报数据.py`
   - `整体周报数据.py`
   - `多事业部日报数据.py`
   - `整体月报数据.py`
   - `多事业部月报数据.py`

### 🔧 解决方案
修改 `save_report_to_local` 函数，在文件名中添加时间戳确保唯一性：

```python
def save_report_to_local(content, report_type="overall_daily"):
    os.makedirs("reports", exist_ok=True)
    # 添加时间戳确保文件名唯一，避免测试时覆盖旧报告
    timestamp = datetime.now().strftime('%H%M%S')
    filename = f"reports/{report_type}_{report_date}_{timestamp}.html"
```

### ✅ 修复结果
**第一次运行**:
```
✅ 报表已保存: reports/overall_daily_2025-07-29_091931.html
✅ API部署成功，公网链接: http://edge.haierht.cn/reports/overall_daily_2025-07-29_091931.html
```

**第二次运行**:
```
✅ 报表已保存: reports/overall_daily_2025-07-29_091945.html
✅ API部署成功，公网链接: http://edge.haierht.cn/reports/overall_daily_2025-07-29_091945.html
```

### 📝 技术要点
1. **时间戳格式**：使用 `%H%M%S` 格式（时分秒），在同一天内提供足够的唯一性
2. **向后兼容**：修改不影响现有的文件处理逻辑
3. **远程同步**：`upload_html_and_get_url` 函数自动获取带时间戳的文件名
4. **存储效率**：时间戳长度固定为6位，不会显著增加文件名长度

### 💡 经验总结
1. **API兼容性的重要性**：客户端和服务器端的参数格式必须保持一致
2. **错误排查的系统性方法**：从日志分析到API测试，逐步缩小问题范围
3. **代码审查的必要性**：客户端代码中的URL处理逻辑可能导致意外问题
4. **测试验证的完整性**：修复后必须进行端到端的功能验证
5. **文件管理的重要性**：在测试环境中避免文件覆盖，确保每次生成的报告都有唯一标识

这些经验将帮助我们更好地维护和优化整个系统。

---

*最后更新：2025-01-30 09:19*